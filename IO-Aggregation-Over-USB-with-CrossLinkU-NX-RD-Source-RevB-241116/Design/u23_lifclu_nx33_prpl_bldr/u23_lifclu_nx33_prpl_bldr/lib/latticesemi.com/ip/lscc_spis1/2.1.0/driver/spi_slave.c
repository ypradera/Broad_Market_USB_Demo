/*
 * =================================================================
     >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
     ------------------------------------------------------------------
     Copyright (c) 2006-2018 by Lattice Semiconductor Corporation
     ALL RIGHTS RESERVED
     ------------------------------------------------------------------

     IMPORTANT: THIS FILE IS AUTO-GENERATED BY LATTICE RADIANT Software.

     Permission:

    Lattice grants permission to use this code pursuant to the
    terms of the Lattice Corporation Open Source License Agreement.

     Disclaimer:

    Lattice provides no warranty regarding the use or functionality
    of this code. It is the user's responsibility to verify the
    user Software design for consistency and functionality through
    the use of formal Software validation methods.

     ------------------------------------------------------------------

     Lattice Semiconductor Corporation
     111 SW Fifth Avenue, Suite 700
     Portland, OR 97204
     U.S.A

     Email: techsupport@latticesemi.com
     Web: http://www.latticesemi.com/Home/Support/SubmitSupportTicket.aspx
     ==================================================================
*/

#include "spi_slave.h"
#include "spi_slave_regs.h"
#include "hal.h"


uint8_t spi_slave_data_read(struct spis_instance *this_spis,uint32_t *data,uint8_t length)
{
	uint8_t count = 0;

	if(this_spis == NULL)
		return SPI_PTR_ERROR;
	/* data get*/
	while(count<length)
	{
		reg_32b_read(this_spis->base_addr | SPI_SLAVE_RD_DATA, &data[count]);
		count++;
	}
	this_spis->status=SPI_SLAVE_READ;
	return SPI_SUCCESS;
}

uint8_t spi_slave_data_write(struct spis_instance *this_spis,uint32_t *data,uint8_t length)
{
	uint8_t count = 0;

	if(this_spis == NULL)
		return SPI_PTR_ERROR;

	for(count=0;count<length;count++)
	{
		reg_32b_write(this_spis->base_addr | SPI_SLAVE_WR_DATA,data[count]);
	}
	this_spis->status=SPI_SLAVE_WRITE;

	return SPI_SUCCESS;
}


uint8_t spi_slave_config(struct spis_instance * this_spis,
			 uint32_t data_width, uint8_t clock_polarity,
			 uint8_t clock_phase, uint8_t daisy_chain,
			 uint8_t ss_polarity)
{
	if(this_spis == NULL)
		return SPI_PTR_ERROR;

	uint8_t spi_slave_config = 0x00;
	this_spis->data_width = data_width;

	this_spis->spi_cpol = clock_polarity;
	this_spis->spi_cpha = clock_phase;
	this_spis->daisy_chain = daisy_chain;
	this_spis->ss_polarity = ss_polarity;


	spi_slave_config = (ss_polarity << 6) | (data_width << 4) | (daisy_chain << 2) | (clock_polarity << 1)| clock_phase;

	reg_8b_write(this_spis->base_addr | SPI_SLAVE_CFG, spi_slave_config);

	reg_8b_write(this_spis->base_addr | SPI_SLAVE_FIFO_RST,
			     SPI_SLAVE_TX_FIFO_RST | SPI_SLAVE_RX_FIFO_RST);

	reg_8b_write(this_spis->base_addr | SPI_SLAVE_BYTE_COUNT_RST,
			     BITS_ALL_SET);

	reg_8b_write(this_spis->base_addr | SPI_SLAVE_FIFO_RST, 0);

	reg_8b_write(this_spis->base_addr | SPI_SLAVE_INT_ENABLE,
				 SPI_SLAVE_INT_RX_BUFFER_READY | SPI_SLAVE_INT_TX_BUFFER_FULL | SPI_SLAVE_INT_TR_COMPLETE);
	reg_8b_write(this_spis->base_addr |	 SPI_SLAVE_INT_STATUS,
					BITS_ALL_SET);

	return SPI_SUCCESS;
}


uint8_t spi_slave_get_status(struct spis_instance *this_spis,uint8_t *status)
{
	if(this_spis == NULL)
		return SPI_PTR_ERROR;

	*status=this_spis->status;
		return SPI_SUCCESS;
}

void spi_slave_isr(void *ctx)
{
	volatile struct spis_instance *this_spis = (struct spis_instance *) ctx;
	uint8_t int_status;
	uint8_t fifo_status;
	uint32_t byte_tx_cnt = 0;
	uint32_t byte_rx_cnt = 0;


	reg_8b_read(this_spis->base_addr |
				SPI_SLAVE_INT_STATUS, &int_status);

	if (int_status & SPI_SLAVE_INT_RX_BUFFER_READY) {

		reg_8b_read(this_spis->base_addr |
								    		SPI_SLAVE_FIFO_STATUS, &fifo_status);
		while((fifo_status & SPI_SLAVE_RX_FIFO_EMPTY) == 0)
		{
			reg_32b_read(this_spis->base_addr |
					SPI_SLAVE_RD_DATA, this_spis->rx_buffer+this_spis->rx_cnt);
			this_spis->rx_cnt++;

			printf("spi slave:%x\r\n",this_spis->rx_buffer[this_spis->rx_cnt]);

			reg_8b_read(this_spis->base_addr |
							    		SPI_SLAVE_FIFO_STATUS, &fifo_status);
		}
		this_spis->status = SPI_SLAVE_READY;
		/*spi slave data parse callback*/
		this_spis->callback.spi_slave_callback(this_spis->callback.context);

		reg_8b_write(this_spis->base_addr |
				     SPI_SLAVE_INT_STATUS,
									 	 SPI_SLAVE_INT_RX_BUFFER_READY);
	}

	if (int_status & SPI_SLAVE_INT_TR_COMPLETE) {
		reg_8b_write(this_spis->base_addr | SPI_SLAVE_FIFO_RST,
				   SPI_SLAVE_RX_FIFO_RST);

		reg_8b_write(this_spis->base_addr | SPI_SLAVE_INT_STATUS,
												      BITS_ALL_SET);
	}

	if(int_status & SPI_SLAVE_INT_TX_BUFFER_FULL) {
		do {
			reg_8b_read(this_spis->base_addr |
					SPI_SLAVE_FIFO_STATUS, &fifo_status);
		}
		while(fifo_status & (SPI_SLAVE_TX_FIFO_FULL));
	}

	reg_8b_write(this_spis->base_addr |
					SPI_SLAVE_INT_STATUS, int_status & BITS_ALL_SET);//clear all pending interrupt
}


uint8_t spi_slave_init(struct spis_instance *this_spis,
		       uint32_t base_addr,
		       uint32_t fifo_depth,
		       uint32_t *slave_tx_buf,uint32_t *slave_rx_buf,void (*spi_callback) (void *), void *context)
{

	if(this_spis == NULL)
		return SPI_PTR_ERROR;
	uint8_t spi_config = 0;
	this_spis->base_addr = base_addr;
	this_spis->fifo_depth = fifo_depth;
	this_spis->tx_buffer=slave_tx_buf;
	this_spis->rx_buffer=slave_rx_buf;

	this_spis->callback.spi_slave_callback = spi_callback;
	this_spis->callback.context = context;


	return SPI_SUCCESS;
}

