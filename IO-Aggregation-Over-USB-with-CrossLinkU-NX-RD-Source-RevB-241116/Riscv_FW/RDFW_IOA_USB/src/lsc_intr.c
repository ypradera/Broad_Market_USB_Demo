/****************************************************************************/
/**
 *
 * @file lsc_intr.c
 * @addtogroup lscusb Overview
 * @{
 *
 *
 *
 *****************************************************************************/

#include "lsc_usb_dev.h"

#define DEBUG_LSC_INTR

#ifdef DEBUG_LSC_INTR
#define LSC_INTR(msg, ...) sprintf(print_buf, msg, ##__VA_ARGS__); lsc_uart_tx(print_buf)
#else
#define LSC_INTR(msg, ...)
#endif

//Previous ctrl out SPI command complete flag
extern    uint8_t previous_ctrl_spi_cmd_cmp;
/*****************************************************************************/
/**
 * @brief
 * Enables an interrupt in Device Event Enable Register.
 *
 * @param  usb_dev is a pointer to the lsc_usb_dev instance.
 * @param  mask is the OR of any Interrupt Enable Masks:
 *       - LSC_DEVTEN_VNDRDEVTSTRCVEDEN
 *       - LSC_DEVTEN_EVNTOVERFLOWEN
 *       - LSC_DEVTEN_CMDCMPLTEN
 *       - LSC_DEVTEN_ERRTICERREN
 *       - LSC_DEVTEN_SOFEN
 *       - LSC_DEVTEN_EOPFEN
 *       - LSC_DEVTEN_HIBERNATIONREQEVTEN
 *       - LSC_DEVTEN_WKUPEVTEN
 *       - LSC_DEVTEN_ULSTCNGEN
 *       - LSC_DEVTEN_CONNECTDONEEN
 *       - LSC_DEVTEN_USBRSTEN
 *       - LSC_DEVTEN_DISCONNEVTEN
 *
 * @return  None
 ******************************************************************************/
void lsc_usb_enable_int (struct lsc_usb_dev *usb_dev, uint32_t mask)
{
    LSC_INTR("lsc_usb_enable_int\r\n");

    uint32_t reg_val = 0;

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DEVTEN);
    reg_val |= mask;

    lsc_32_write((usb_dev->base_add + LSC_DEVTEN), reg_val);
}

/*****************************************************************************/
/**
 * @brief
 * Disables an interrupt in Device Event Enable Register.
 *
 * @param  usb_dev is a pointer to the lsc_usb_dev instance.
 * @param  mask is the OR of Interrupt Enable Masks
 *       - LSC_DEVTEN_VNDRDEVTSTRCVEDEN
 *       - LSC_DEVTEN_EVNTOVERFLOWEN
 *       - LSC_DEVTEN_CMDCMPLTEN
 *       - LSC_DEVTEN_ERRTICERREN
 *       - LSC_DEVTEN_SOFEN
 *       - LSC_DEVTEN_EOPFEN
 *       - LSC_DEVTEN_HIBERNATIONREQEVTEN
 *       - LSC_DEVTEN_WKUPEVTEN
 *       - LSC_DEVTEN_ULSTCNGEN
 *       - LSC_DEVTEN_CONNECTDONEEN
 *       - LSC_DEVTEN_USBRSTEN
 *       - LSC_DEVTEN_DISCONNEVTEN
 ******************************************************************************/
void lsc_usb_disable_int (struct lsc_usb_dev *usb_dev, uint32_t mask)
{
    LSC_INTR("lsc_usb_disable_int\r\n");

    uint32_t reg_val = 0;

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DEVTEN);
    reg_val &= ~mask;

    lsc_32_write((usb_dev->base_add + LSC_DEVTEN), reg_val);
}

/****************************************************************************/
/**
 * Processes an Event generated by controller. Events are either
 * Device/Endpoint specific event.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    event is the Event entry.
 *
 * @return   None.
 *
 * @note     None.
 *****************************************************************************/
void lsc_usb_evt_handler (struct lsc_usb_dev *usb_dev,
        const union lsc_event *event)
{
//    LSC_INTR("lsc_usb_evt_handler\r\n");

    if (event->evt_type.is_dev_evt == 0) {
        //End point Specific Event
        lsc_usb_ep_event(usb_dev, &event->ep_evt);
        return;
    }

    switch (event->evt_type.type) {
        case LSC_EVENT_TYPE_DEV:
            //Device Specific Event
            lsc_usb_dev_event(usb_dev, &event->dev_evt);
            break;

        default:
            //LSC_INTR("Invalid Events.!!\r\n");
            break;
    }
}

/****************************************************************************/
/**
 * @brief
 * Main USB Controller Interrupt Handler.
 *
 * @param    context is a void pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     None.
 *****************************************************************************/
void lsc_usb_int_handler (void *context)
{
    LSC_INTR("\r\n--- MAIN USB CONTROLLER INTERRUPT HANDLER : lsc_usb_int_handler ---\r\n");

    struct lsc_usb_dev *l_usb_dev;
    struct lsc_evt_buffer *evt;

    uint32_t evt_count = 0, reg_val = 0;

    l_usb_dev = (struct lsc_usb_dev*)context;
    evt = &l_usb_dev->evt;

    evt_count = lsc_32_read(l_usb_dev->base_add + LSC_GEVNTCOUNT(0));
    //LSC_INTR("evt_count: %x\r\n", evt_count);

    evt_count &= LSC_GEVNTCOUNT_MASK; //bit0_1 in tihs mask is kept as 0 because every event is of 4 byte.

    //Return, if evt_count is 0
    if (evt_count == 0) {
        return;
    }

    evt->count = evt_count;
    evt->flags |= LSC_EVENT_PENDING;

    //Mask event interrupt
    reg_val = lsc_32_read(l_usb_dev->base_add + LSC_GEVNTSIZ(0));
    reg_val |= LSC_GEVNTSIZ_INTMASK;
    lsc_32_write((l_usb_dev->base_add + LSC_GEVNTSIZ(0)), reg_val);

    lsc_usb_evt_buf_handler(l_usb_dev);
}

/****************************************************************************/
/**
 * Link Status Change Interrupt handler.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    evt_info is Event information.
 *
 * @return   None.
 *
 *****************************************************************************/
void lsc_usb_link_sts_change_int (struct lsc_usb_dev *usb_dev,
        uint32_t evt_info)
{
    LSC_INTR("lsc_usb_link_sts_change_int\r\n");

    usb_dev->link_state = (evt_info & LSC_LINK_STATE_MASK);

    lsc_read_dev_status_reg(usb_dev);
}

/****************************************************************************/
/**
 * Connection Done Interrupt handler.
 * This function performs initialization of controller when device is
 * attached to the HOST.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *****************************************************************************/
void lsc_usb_connect_int (struct lsc_usb_dev *usb_dev)
{
    LSC_INTR("lsc_usb_connect_int\r\n");

    uint32_t reg_val = 0;
    uint16_t size = 0;
    uint8_t speed;

    uint32_t hw_ver = lsc_32_read(HW_VER_GPIO_INST_BASE_ADDR);
    LSC_INTR("FPGA Version: %x.%x.%x.%x\r\n", ((hw_ver >> 24) & 0xFF), ((hw_ver >> 16) & 0xFF), ((hw_ver >> 8) & 0xFF), (hw_ver & 0xFF));

    LSC_INTR( "RISC V Version: %x.%x\r\n", ((LSC_RISCV_VER >> 4) & 0xF), (LSC_RISCV_VER & 0xF));

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DSTS);
    speed = reg_val & LSC_DSTS_CONNECTSPD;
    usb_dev->dev_speed = speed;

    switch (speed) {
        case LSC_DCFG_SUPERSPEED:
            LSC_INTR("Super Speed\r\n");
            size = 512;
            usb_dev->dev_speed = LSC_SPEED_SUPER;
            break;

        case LSC_DCFG_HIGHSPEED:
            LSC_INTR("High Speed\r\n");
            size = 64;
            usb_dev->dev_speed = LSC_SPEED_HIGH;
            break;

        case LSC_DCFG_FULLSPEED2:
        case LSC_DCFG_FULLSPEED1:
            LSC_INTR("Full Speed\r\n");
            size = 64;
            usb_dev->dev_speed = LSC_SPEED_FULL;
            break;

        case LSC_DCFG_LOWSPEED:
            LSC_INTR("Low Speed\r\n");
            size = 64;
            usb_dev->dev_speed = LSC_SPEED_LOW;
            break;
        default:
            LSC_INTR("Unknown Speed\r\n");
            size = 64;
            break;
    }

    if (usb_dev->dev_speed == LSC_SPEED_SUPER) {
        reg_val = lsc_32_read(usb_dev->base_add + LSC_DCTL);
        reg_val &= ~LSC_DCTL_HIRD_THRES_MASK;
        lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);
    }

    ////////////////// For LPM Support //////////////////

#ifdef LSC_LPM_ENABLE
    //Enable LPM Support
    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCFG);
    reg_val |= LSC_DCFG_LPM_CAP;
    lsc_32_write((usb_dev->base_add + LSC_DCFG), reg_val);

    reg_val = lsc_32_read(usb_dev->base_add + LSC_GUCTL1);
//        reg_val |= 0x80000000;   //bit_31 - DEV_DECOUPLE_L1L2_EVT
    reg_val |= 0x1000000;   //bit_24 - DEV_L1_EXIT_BY_HW
    lsc_32_write((usb_dev->base_add + LSC_GUCTL1), reg_val);

    //As of now not needed for LPM L1 USB CV CH9 Test.
//    reg_val = lsc_32_read(usb_dev->base_add + LSC_GUCTL1);
//    reg_val |= 0x1000000;   //bit_24 - DEV_L1_EXIT_BY_HW
//    lsc_32_write((usb_dev->base_add + LSC_GUCTL1), reg_val);
//
//    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCTL);
//    reg_val |= LSC_DCTL_HIRD_THRES(0xF);
//    reg_val &= ~LSC_DCTL_APPL1RES;
//    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);

#else
    //Disable LPM Support
    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCFG);
    reg_val &= ~LSC_DCFG_LPM_CAP;
    lsc_32_write((usb_dev->base_add + LSC_DCFG), reg_val);
#endif
    ////////////////// For LPM Support //////////////////

    lsc_usb_enable_ctrl_ep(usb_dev, size);
    lsc_usb_rcv_setup(usb_dev);
}

/****************************************************************************/
/**
 * Disconnect Interrupt handler.
 * This function performs initialization of controller when device is
 * disconnected from the HOST.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     This function is called when controller genrates Device
 *           Disconnect Event.<br>
 *****************************************************************************/
void lsc_usb_disconn_int (struct lsc_usb_dev *usb_dev)
{
    LSC_INTR("lsc_usb_disconn_int\r\n");

    uint32_t reg_val = 0;

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCTL);

    reg_val |= LSC_DCTL_ULSTCHNGREQ(5);
    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);

    reg_val |= LSC_DCTL_RUN_STOP;
    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);

//    reg_val &= ~LSC_DCTL_INITU1ENA;
//    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);
//
//    reg_val &= ~LSC_DCTL_INITU2ENA;
//    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);

    usb_dev->is_config_done = 0;
    usb_dev->dev_speed = LSC_SPEED_UNKNOWN;

    usb_dev->is_enum_done = 0;

}

/****************************************************************************/
/**
 * Reset Interrupt handler.
 * This function performs initialization of controller during USB Reset.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *****************************************************************************/
void lsc_usb_reset_int (struct lsc_usb_dev *usb_dev)
{
    LSC_INTR("lsc_usb_reset_int\r\n");

    uint32_t reg_val = 0;

    usb_dev->dev_state = LSC_STATE_DEFAULT;

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCTL);
    reg_val &= ~LSC_DCTL_TSTCTRL_MASK;
    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);
    usb_dev->test_mode = 0;

    lsc_usb_stop_active_transfers(usb_dev);
    lsc_usb_clear_stall_all_ep(usb_dev);

    for (int i = 0; i < (usb_dev->num_in_eps + usb_dev->num_out_eps); i++) {
        usb_dev->eps[i].ep_status = 0;
    }

    usb_dev->is_config_done = 0;
    usb_dev->is_enum_done = 0;

    sprintf(print_buf, "***** &&&& Reseting the ctrl spi cmd &&&& ****\r\n");
    lsc_uart_tx(print_buf);
    previous_ctrl_spi_cmd_cmp=1;

    /* Reset device address to zero */
    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCFG);
    reg_val &= ~LSC_DCFG_DEVADDR_MASK;
    lsc_32_write((usb_dev->base_add + LSC_DCFG), reg_val);
}

/****************************************************************************/
/**
 * Handles Interrupts of Control Endpoints EP0 OUT and EP0 IN.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    event is a pointer to the Endpoint event occurred in core.
 *
 * @return   None.
 *
 * @note     This funtion is called when controller generates control
 *           endpoint related events.
 *****************************************************************************/
void lsc_usb_ep0_intr (struct lsc_usb_dev *usb_dev,
        const struct lsc_event_epevt *event)
{
    LSC_INTR("lsc_usb_ep0_intr\r\n");

    LSC_INTR("	ep_event: %x - ep_number: %x \r\n;", event->ep_event, event->ep_number);

    switch (event->ep_event) {
        case LSC_DEPEVT_XFERCOMPLETE:
            lsc_usb_ep0_xfer_cmplt(usb_dev, event);
            break;

        case LSC_DEPEVT_XFERNOTREADY:
            lsc_usb_ep0_xfer_not_ready(usb_dev, event);
            break;

        case LSC_DEPEVT_XFERINPROGRESS:
        case LSC_DEPEVT_STREAMEVT:
        case LSC_DEPEVT_EPCMDCMPLT:
            break;

        default:
            //LSC_INTR("Invalid Ep0 Events.!!\r\n");
            break;
    }
}

/****************************************************************************/
/**
 * Resume/Remote Wakeup Detected Event (WkUpEvt) handler.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     This function is called when HOST initiates resume from
 *           U3/L2 or U3/L2L1 state and controller will generates
 *           wakeup event.<br>
 *****************************************************************************/
void lsc_usb_wakeup_int (struct lsc_usb_dev *usb_dev)
{
    printf("lsc_usb_wakeup_int\r\n");

//    lsc_usb_set_link_state(usb_dev, LSC_LINK_STATE_CHANGE_RECOV);
}

/****************************************************************************/
/**
 * GPIO Interrupt handler.
 *
 * @param    context is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     This function is used to initiate device remote wakeup.
 *           On pressing GPIO, this ISR will perfrom setting usb link
 *           state to Recovery to acknowledge the resume/reset request.<br>
 *           Setting link state to recovery initiates remote wakeup request
 *           from device.<br>
 *****************************************************************************/
void lsc_gpio_int_handler (void *context)
{
    printf("GPIO Interrupt\r\n");

    struct lsc_usb_dev *l_usb_dev;
    l_usb_dev = (struct lsc_usb_dev*)context;

    uint32_t gpio_int_sts = 0;

    // Read I2C Master Interrupt Source register
    //Ref: https://elixir.bootlin.com/linux/v6.6.7/source/drivers/usb/dwc3/gadget.c#L2352
    gpio_int_sts = lsc_32_read(GPIO0_INST_BASE_ADDR + GPIO_INT_STATUS);
    printf("gpio_int_sts:%x\r\n", gpio_int_sts);

    // Write same value back to clear interrupts in interrupt source
    lsc_32_write((GPIO0_INST_BASE_ADDR + GPIO_INT_STATUS), gpio_int_sts);

    //Device initiated remote wakeup
    if (l_usb_dev->wakeup_selfpowered
            & DEVICE_STATUS_REMOTE_WAKEUP_BUS_POWERED_10_VALUE) {
//        uint32_t retries = 0, reg_val = 0;
        lsc_usb_set_link_state(l_usb_dev, LSC_LINK_STATE_CHANGE_RECOV);

//        retries = 20000;
//
//        while (retries--) {
//            reg_val = lsc_32_read(l_usb_dev->base_add + LSC_DSTS);
//
//            /* in HS, means ON */
//            if (LSC_DSTS_USBLNKST(reg_val & LSC_DSTS_USBLNKST_MASK)
//                    == LSC_LINK_STATE_U0) {
//                printf("-----\r\n");
//                break;
//            }
//        }
    }
}

/** @} */
