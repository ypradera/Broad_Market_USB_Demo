// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// ------------------------------------------------------------------

/****************************************************************************/
/**
 *
 * @file main.c
 *
 * This file implements the USB Device Controller.
 *
 *
 *****************************************************************************/

#include "lsc_usb_dev.h"
#include "utils.h"
#include "pic.h"
#include "lsc_usb_vendor.h"
#include "timer.h"



#define LSC_USB_DEV_BASE_ADD                  0x20000
#define USB20SR_PIC_START_ADDR                CPU0_INST_PICTIMER_START_ADDR     /**< USB20SR PIC Start Address. */
#define USB20SR_IRQ                           1                                 /**< USB20SR Control Port IRQ. */
#define I2C_BASE LATTICE_I2CC_MASTER_INST_BASE_ADDR
//#define I2C_BASE_1  //define the base address

#define TEST_ADDR       0x000F0000


#define MAIN

#ifdef MAIN
#define DEBUG_MAIN(msg, ...) sprintf(print_buf, msg, ##__VA_ARGS__); lsc_uart_tx(print_buf)
#else
#define DEBUG_MAIN(msg, ...)
#endif


struct uart_instance uart_core_uart;
struct lsc_usb_dev usb_device;
struct lsc_usb_dev *usb_dev; 
struct plat *pdata;
struct plat platform;

_Response response;
_Response *resp;

struct gpio_instance gpio_inst[NUM_GPIO_CONTROLLER];
struct i2cm_instance  i2c_dev[NUM_I2C_CONTROLLER];
lsc_spi_dev spi_dev[NUM_SPI_CONTROLLER];


uint8_t print_buf[256];

uint8_t isr_register (uint32_t pic_start_add, uint32_t usb_irq,
        void (*isr) (void*), void *context)
{

    pic_init(pic_start_add);

    if (pic_isr_register(usb_irq, isr, context)) {

        return LSC_FAIL;
    }

    return LSC_SUCCESS;
}

/**
 * @fn void configure_spi(lsc_spi_dev *pSpiDev, uint8_t irq_num)
 *  @brief This is used to configure SPI IRQ.
 *  @param pSpiDev Pointer to lsc_spi_dev device strcuture
 *  @param irq_num Holds SPI Device IRQ Number
 *
 *  @return void
 */
void configure_spi (lsc_spi_dev *this_spi_m, uint8_t irq_num)
{
    uint8_t ret = 0;

    this_spi_m->spi_intr = 0x00;
    this_spi_m->event = 0x00;
    this_spi_m->spi_irq = irq_num;

    if (!(ret = pic_isr_register(irq_num, spi_isr, this_spi_m))) {
        sprintf(print_buf, "spi_isr success\r\n");
        lsc_uart_tx(print_buf);
    }
}

/*****************************************************************************/
/**
 *  @brief This is used to configure I2C IRQ, interrupt enable and master control registers.
 *  @param pI2cDev Pointer to i2c_master device strcuture
 *  @param base Holds I2C Device base address
 *  @param irq_num Holds I2C Device IRQ Number
 *
 *  @return None.
 *
 *  @note     None.
 ******************************************************************************/
void configure_i2c (struct i2cm_instance* pI2cDev, uint32_t base, uint8_t irq_num)
{
    int8_t ret = 0;

    pI2cDev->i2c_irq = irq_num;
    pI2cDev->addr_mode = I2CM_ADDR_10BIT_MODE;
    pI2cDev->interrupts_en = 0xFF;

    // Initializing I2C Device Controller.
    if ((ret = i2c_master_config(pI2cDev)) < 0) {
        sprintf(print_buf, "i2c initilization fail\r\n");
        lsc_uart_tx(print_buf);
    }
}


int main (void)
{
    uint8_t status;
    resp = &response;
    pdata = &platform;
    usb_dev = &usb_device;

    // Initialize UART
    uart_init(&uart_core_uart, UART0_INST_BASE_ADDR, CPU_FREQUENCY,
            UART0_INST_BAUD_RATE, 1, 8);

#ifdef LSCC_STDIO_UART_APB
    extern struct uart_instance *g_stdio_uart;
    g_stdio_uart = &uart_core_uart;
#endif

    DEBUG_MAIN("Broad Market USB23 Rev1.9.5 \r\n");
    
    // Initialize GPIO
    gpio_init(&gpio_inst[0], GPIO0_INST_BASE_ADDR, GPIO_INDEX0_LINE_NUM, GPIO_INDEX0_DIR);

    // Clear pending interrupts if any during initialization.
    lsc_32_write((GPIO0_INST_BASE_ADDR + GPIO_INT_STATUS),0xFFFF);

    // Enable GPIO Interrupts
    lsc_32_write((GPIO0_INST_BASE_ADDR + GPIO_INT_ENABLE),  0xFFFF);


    // Initializing Device Controller.
    // for Initializing Registers.
    status = lsc_usb_init(usb_dev, LSC_USB_DEV_BASE_ADD);
    if (status != LSC_SUCCESS)
        return LSC_FAIL;

    // Register USB ISR into Interrupt Controller
    status = isr_register(USB20SR_PIC_START_ADDR, USB20SR_IRQ,
            lsc_usb_int_handler, usb_dev);
    if (status != LSC_SUCCESS)
        return LSC_FAIL;

    // Register GPIO ISR into Interrupt Controller
    status = pic_isr_register(GPIO0_INST_IRQ, lsc_gpio_int_handler, usb_dev);
    if (status != LSC_SUCCESS)
    {
        sprintf(print_buf, "GPIO ISR Fail.");
        lsc_uart_tx(print_buf);

        return LSC_FAIL;
    }

    // Initialize SPI
    pdata->pSpiDev[0] = &spi_dev[0];
    spi_init(pdata->pSpiDev[0], SPI_CONTROLLER_0);
    configure_spi(pdata->pSpiDev[0], SPISR_IRQ1);

    //Initialize Another SPI Controller
    // Initialize SPI
    //pdata->pSpiDev[1] = &spi_dev[1];
    //spi_init(pdata->pSpiDev[1], SPI_CONTROLLER_1);
    //configure_spi(pdata->pSpiDev[1], SPISR_IRQ1);

    // Init I2C Controller for Lattice I2C
    pdata->pI2cDev[0] = &i2c_dev[0];
    i2c_master_init (pdata->pI2cDev[0], I2C_BASE);
    //Testing
    //configure_i2c(pdata->pI2cDev[0], I2C_BASE, I2C_MSTR1_IRQ);
    //configure_spi(pdata->pI2cDev[0], SPISR_IRQ1);

     //Initialize Another I2C  Controller
    //pdata->pI2cDev[1] = &i2c_dev[1];
    //i2c_master_init (pdata->pI2cDev[1], I2C_BASE_1);

    // Enable Device Event Interrupts into Device Event Enable Register.
    // for Device Event Enable Register (DEVTEN).
    lsc_usb_enable_int(usb_dev, LSC_DEVTEN_MASK);

    //added for usb3.0
   lsc_32_write(LSC_USB_DEV_BASE_ADD | 0x000100AC, 0x020E4500); // 402b

    //Setting vendor request handler here to perform vendor specific task.
    usb_dev->usb_vendor_req_handler = lsc_usb_vendor_req;

    lsc_usb_start(usb_dev);

    // USB3 PHY 0x8c to 0x8f //added for usb3.0
    lsc_32_write(LSC_USB_DEV_BASE_ADD | 0x0001008C, 0x90d40001); // 4023

    init_mtime();

    while (1) {
    }

    return LSC_SUCCESS;
}

